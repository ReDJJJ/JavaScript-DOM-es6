<!doctype html>
<html>
   <head>
       <meta charset="utf-8" />
       <title></title>
       <style>
       </style>
   </head>

   <body>
       <!-- 断点: 调试的断点 -->
       <!-- 
            如何设置
            1在需要断点的代码位置 写入debugger;
            2点击浏览器调试器的行号位置 设置断点(此种设置方法,断点那行的代码不执行)

            调试器的使用;
            第一个按钮:断点到断点的跳转(并执行中间代码)
            第二个按钮:选择性地执行顺序一步一步地执行代码(一按一步),遇到函数时,(函数内有断点)则进入函数执行的内部过程,(函数内无断点),直接函数执行完成
            第三个按钮:真正地一步步走,并且会进入函数内部执行过程一步步走
            第四个按钮:跳出当前函数的执行过程(前提在函数内部)
            第五个按钮:真真正正地最详细的一步步按顺序执行
            第六个按钮:切换所有断点的可用状态  当前可用/当前不可用  
        -->
       <script>

           function fn1(){ 
                var a = 100;
                var b = 100; 
                c = 300; //全局c
                // debugger; 第三个,若没有调用fn1,那此断点没有意义,因为函数定义不执行
                // 在此断点中,局部作用域的内容(浏览器打印结果)
                // a: 100
                // b: 100
                // fn2: ƒ fn2()
                // this: Window

                function fn2(){ 
                    var d = 40;
                    b = 1000; //全局d
                }
                fn2();//fn2是在fn1()中定义的,所以只能在fn1中调用;
           }

           var a = 10;
           var b = 20;
           var c = 30;
        //    debugger; 第一个
           
        //  debugger; 第二个
           fn1();

           //程序执行过程(超级详细版):
           /*
           预解析:function fn1(){ 
               黑盒
           }
           var了三个全局变量a,b,c;
           预解析完成:
           三个全局变量a,b,c赋值;
           执行fn1();
           {
               fn1()内部预解析;(a,b是在fn1内部定义的,是局部变量,c既不是内部var也不是形参,但在全局变量中存在,所以是调用全局变量)
               局部变量a,b 赋值;
               全局变量c 赋值;
               声明局部函数fn2();
               执行fn2();
                {
                    fn2()内部预解析;
                    局部变量d = 40;
                    fn1的变量b = 1000;
                }
           }
           */
       </script>
   </body>
</html>