<!-- 
    JS是一个单线程流水线 (线程依赖于进程,一个进程至少有一个线程,线程是CPU调度的最小单元)
    JS中的同步和异步  
    同步: 按照先后顺序依次执行,同一时刻只能执行一行代码;
    异步: 不按照先后顺序执行 ,  要等所有同步代码执行完后再执行异步代码

    
    js是单线程同步执行,只不过异步这个机制看起来js同时干了两件事(记时的同时继续执行下列代码)
    所有的定时器还有事件回调都是异步操作(ajax 生命周期回调函数)
        代码可以分为同步代码和异步代码
        异步代码是要等同步代码执行完成之后才会执行的(因为js是单线程)

    
所谓"单线程"，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。
这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。

为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。

"同步模式"就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；"异步模式"则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。

"异步模式"非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，"异步模式"甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。

异步调用并不会阻止代码的顺序执行，而是在将来的某一个时刻触发设置好的逻辑，所以我们
并不知道逻辑什么时候会被调用
只能定义当触发的时候逻辑是什么
只能等待，同时可以去处理其他的逻辑
 -->

<!doctype html>
<html>
   <head>
       <meta charset="utf-8" />
       <title></title>
       <style>

       </style>
   </head>

   <body>
       <script>
           //第一个案例: 
            setTimeout(function(){
                console.log("1");
            },5000);
            console.log("2");
            // 结果先设置定时器(开始计时,回调函数进入任务队列)先打印2   后打印1
            //执行过程  
            //1 按照同步代码由上往下执行  先执行setTimeout, 先设置一个定时器(此设置过程是同步的,开始计时2s), 但是定时器中的回调函数是异步的,要等所有同步代码执行完后再执行,所以回调函数此时搁置了
            //2 继续执行同步代码,打印console.log("2");
            //3 打印完2,执行完了所有同步代码,开始执行异步代码,异步代码队列第一个就是setTimeout的回调函数 ,开始执行计时器的回调函数打印1.
            // 倘若 打印2 是一个耗时间的同步代码,那么异步代码也要等待(哪怕2s计时已到),,也要等所有同步代码执行完后再执行回调函数(打印1)


            // 问题 假如我想延时打印完1后再打印2呢？ 怎么做?
            // 解决方案: 使用定时器时候,不要和耗时的同步操作放在一起;
            // 假若一定有一个耗时同步代码和定时器放在一起,导致定时器不准怎么办?
            // 解决方案: 高级篇有 模拟多线程的做法;


       </script>
   </body>
</html>