1如何产生闭包(条件)
    函数嵌套
    内部函数引用外部函数的局部变量 内部函数引用了外部函数的作用域
    外部函数被调用过,内部函数也需要调用或引用(内部函数地址被引用); 外部函数不调用,内部函数连定义某没有,内部函数不调用或引用,相当于白白定义

闭包在内部函数定义的时候就已经出现了,因为定义的时候上级作用域链.[scopes]也确定了。

2闭包到底是什么
    第一层:闭包是嵌套的内部函数;
    第二层:闭包是一个存在于内部函数(作用域链)的引用关系,该引用关系 引用的是外部函数的变量;


3常见的闭包:
    1内部函数(地址)作为外部函数的返回值;
    2内部函数作为实参传递给另一个函数调用;
    3使用闭包实现私有方法操作独立的私有属性;

4闭包的作用:
    1延长外部函数变量对象的生命周期
    2让函数外部可以操作(读写)函数内部的数据(函数内部的变量或者子函数)
    3保护内部变量防止被污染

5闭包的生命周期:
    1产生:在嵌套内部函数定义执行完时就产生了(不是在调用)
    2死亡:在嵌套的内部函数称为垃圾对象 (嵌套的内部函数没有被指向)

所以闭包是双刃剑:每个独立闭包一旦产生则一直占用内存;
如果闭包使用完成,切记让嵌套函数变成垃圾对象 以清除闭包;

经验:闭包持续存在必须有一个最外部变量 来指向 函数内部的嵌套函数,否则函数执行完后执行环境和函数堆内存的内容就被清空了,无法形成闭包;所以理解闭包要找到形成闭包的关键索引!!
     每个变量代表多个独立的闭包
     而作用域链中要仔细甄别对应的闭包;

<!doctype html>
<html>
   <head>
       <meta charset="utf-8" />
       <title></title>
       <style>
       </style>
   </head>

   <body>
       <script>
          //闭包原始案例
          function fn1(){
              var a = 0;
              function fn2(){
                a++;
                console.log(a);
              }
              return fn2; //引用,返回fn2的地址
          }

          var f= fn1();
          f();//可以执行,f现在指向了fn1内部函数fn2的地址,并且调用了外部函数fn1的变量;
          f = null; //清除闭包;


       </script>
   </body>
</html>