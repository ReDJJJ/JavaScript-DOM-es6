<html>
    <head>
        <meta charset="utf-8" />
        <title></title>
        <style>

        </style>
    </head>

    <body>
        <script>
            // 学习了 基本数据类型之间的隐式转化和显式转化,现在来学习对象数据类型的隐式转化

            // 所有对象转化成布尔值都是true !对象 = false;
            
            // 拥有对象数据类型的判断和运算表达式 :
            // 1如果是两个对象数据类型判等==,如果两边都是对象,只看地址,地址相同就相同,地址不同就不等
            // 2如果不是两个对象之间进行判等(两个对象比大小和运算,对象和基本数字类型比较和运算), 则对象数据类型一方需要转化成基本数据类型再进行比较大小或者运算
            // 也就是说,只要不是两个对象在判等 其余所有包含对象的表达式 其对象数据类型都需要转化成基本数据类型在进行 基本数据类型之间的判断和运算

            // 对象(数组 , 函数 ,对象 )转化成基本数据类型过程
            // 1首先对象都会先调用valueOf()方法,返回其自身本体,valueof中基本数据类型重写，而对象共用Object的的原型中的属性
            // 2由于valueOf()返回本体,则会调用toString()方法转化为基本值
            // 不同于对象调用valueOf()共用Object.prototype里的valueOf(),数组,函数,对象各自的构造函数(Array(),Function(),Object())重写(层叠)了toString(),根据原型链就近进行查找
            //  数组.toString() --- 数组会转化为 砍掉[] 剩余的内容 的字符串
            //  函数.toString() --- 函数本体整体加 '' ,长成函数本体样子的字符串
            //  对象.toString() --- 直接 "[object Object]" 字符串

            // 在对象转成字符串后 ,便成为字符串进行后续的操作;

            var a = [1,2,3] , b = function(x,y) {return x;} , c = {name : "hj" , age : 100};
            console.log(a.toString()); //数组转化为基本值 1,2,3
            console.log(b.toString());  // function(x,y) {return x;}
            console.log(c.toString());  // [object Object]


            //案例
            console.log(([1,2]+1)); // "1,2" + 1 
            // 有对象,但不是两个对象判等,先进行对象转基本 , [1,2] --> "1,2"  
            console.log(([1,2]*1)); // "1,2" * 1  -- NAN * 1 -- NAN
            //对象哪怕要转换成数字类型，也是先从字符串类型转tostring
            console.log([]==[]); // 两个数组(对象)判等,看地址,两个不同对象,堆内存地址肯定不同; false
            console.log([]==![]); // ！优先级高, ![], !是单运算符与!结合的都是布尔值 , 所有对象转布尔值都是true 
                                    //[] == false  不是两个对象判断,对象[]转基本类型砍[] 变成空串'' , 判等两个类型不相等 ,都Number()化, '' == ！true , 0 == 0;            // ！！！重点关注 [] == ![];
            
            
            

        </script>
    </body>
</html>