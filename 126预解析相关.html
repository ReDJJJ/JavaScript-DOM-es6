<!-- 执行上下文(执行上下文环境)
    程序在解析和运行的时候所依赖和使用的环境
    全局执行上下文环境和函数执行上下文环境 (就是以前说的全局环境和函数环境)
    
执行上下文栈(就是以前的栈内存)
    程序为了管理执行上下文(程序的执行顺序)所创建的一个栈结构数据,被称为执行上下文栈

预解析:(真正过程是形成变量对象)
    先function,函数重名覆盖
    后var,变量重名忽略(包括与function重名)

作用域:抽象概念,变量作用的范围(函数在定义时便确定了作用域,也确定了上级作用域链)
作用域链:真实存在的,使用执行上下文当中变量对象所组成的链条结构(数组结构) 

抽象来说:先找自身作用域若无找上一级,一级级往上找
真实来说:先去自身的变量对象当中查找,若无,去上级执行上下文环境中的  变量对象 当中去查找,直至找到全局执行上下文的变量对象.

全局执行上下文环境 分为创建阶段和执行阶段  (以前是环境先入栈再构建全局环境,其实是先构建全局环境再入栈)
        创建阶段:
            1收集变量,生成变量对象,变量对象包括了function函数和var变量,变量对象本质就是一大堆指向堆内存的地址的集合;(创建变量对象过程就是预解析)//以前变量存放在全局上下文中(栈中)是不对的,但是可以理解成那样,方便看出程序执行顺序
            2确定this的指向 (全局的为window)
            3确定作用域链
                    同时将函数在调用时候的上级作用域链赋值给函数的属性[scope]数组,若有闭包,此时闭包也添加了
                    上级作用域(根据ECMA语法:看函数内部是否调用了外部变量,若有则将外部变量的所属变量对象添加到上级作用域中,最后最外层加上全局变量对象)(其实就是优化作用域链长度,抛弃作用域链中不需要(未涉及)的变量对象)
        执行阶段:
            1为变量真正赋值;
            2顺着作用域链查找要使用的变量或函数执行;

函数执行上下文环境 
        创建阶段:
            1收集变量形成变量对象 , 收集范围: function var argument 形参
            2指定this
            3确定作用域链
                函数在 !!  定义  !!的时候函数上级的作用域链已经确定,因此函数确定作用域链时,只需要将自己的变量对象添加到最内部
        执行阶段:
            为变量真正赋值
            顺着作用域链查找变量或函数执行

1入栈前就创建了执行上下文(执行环境):三步 收集变量形成变量对象 确定this指向 创建自身作用域链 
 -->

<!doctype html>
<html>
   <head>
       <meta charset="utf-8" />
       <title></title>
       <style>
       </style>
   </head>

   <body>
    创建阶段在入栈前 -- 可在代码第一行添加断点,此时不执行任何一行代码,但是在调试器中,Call Stack一栏出现了,代表着代码执行之前创建了全局执行上下文环境后环境入栈了.
    调试器中可看 Scope一栏:就是作用域链 ,里面可用看到环境内(全局和函数们)的变量对象,而作用域链就是由内到外,一层层环境的变量对象组成的,本层找不到到上一层,直到全局环境的变量对象
    所以查看scope可用查找当前位置的作用域链,有几个变量对象就有几层,例如fn2中的scope就有三个变量对象,分别是local(自身) fn1(fn1) 和global(全局)
       <img src="./img/28.png" alt="">
       <script>
           function fn1(){ 
                var a = 100;
                var b = 100; 
                c = 300; 
                function fn2(){ 
                    var d = 40;
                    b = 1000; //若注释此行,fn2不再调用外部函数fn1的变量b,则fn1的变量对象移出到fn2的作用域链;
                }
                fn2();
            }
           var a = 10;
           var b = 20;
           var c = 30;
           fn1();
       </script>
       <!-- 
            关键问题: 我们现在知道 作用域链就是每个环境的变量对象 嵌套串联起来的,问题是 fn1创建执行环境时候怎么知道上一级作用域是全局环境的变量对象呢?

            都说函数定义的时候上一级作用域就确定了,那本身作用域链也确定了.
            因为在函数定义的时候,函数没有执行,函数就不会创建执行上下文(所以argument,形参什么的都是空的),但是定义的时候函数自身所带的属性.[scope](是个数组)记录了上一级作用域链,函数执行的时候根据scope数组再加上自己的作用域就构成了完整的作用域链;

        -->
   </body>
</html>